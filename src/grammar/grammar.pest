// The main rule. soi and eoi only parsers when complete (not before). This prevents parsing errors
main = { soi ~ (expression_literal)* ~ eoi }

expression_literal = _{ string_literal | function_literal | function_call_literal | list_literal | boolean_literal | identifier_literal | numeric_literal }

function_literal = { "(" ~ identifier_literal ~ args_list ~ expression_literal ~ ")" }

args_list = { "[" ~ identifier_literal* ~ "]" | "[" ~ "]"}

function_call_literal = { "(" ~ identifier_literal ~ expression_literal*? ~ ")" }

list_literal = { "[" ~ expression_literal* ~ "]" | "[" ~ "]" }

// We must differentiate between parsing identifiers, boolean literals and identifiers which begin with boolean literals
// For example, "true", "hello" and "trueexample"
// The below parsing is odd, but it works.
identifier_literal = @{ !boolean_literal ~ identifier }

identifier = @{ (alpha | "_") ~ (alpha_numeric | "_")* }

alpha_numeric = _{ alpha | decimal_digit }

alpha = _{ 'a'..'z' | 'A'..'Z' | symbol_literal }

symbol_literal = _{ 
    "." | ";" | "," | "<" | ">" | "=" | "!" | "+" | "-" | "*" | "/" | "&" | "|" | "^" | "~" | "?" | ":"
}

boolean_literal = @{ ("true" | "false") ~ !identifier_literal }

string_literal = @{ "\"" ~ (escape_code | !("\"" | "\\") ~ any)* ~ "\"" }

escape_code = @{ "\\" ~ ("\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v" | "0") }

numeric_literal = _{ hex_digits_literal | oct_digits_literal | binary_digits_literal | decimal_digits_literal }

decimal_digits_literal = @{ ("0" | ('1'..'9') ~ decimal_digit*) ~ exponent_part? }

exponent_part = @{ ("e" | "E") ~ decimal_digits_literal }

binary_digits_literal = @{ ("0b" | "0B") ~ '0'..'1'* }

oct_digits_literal = @{ ("0o" | "0O") ~ '0'..'7'* }

hex_digits_literal = @{ ("0x" | "0X") ~ (decimal_digit | 'A'..'F')* }

decimal_digit = { '0'..'9' }

// Exists for use in whitespace and comment rules
newline = _{ "\r" | "\n" }

whitespace = _{ " " | "\t" | newline }

comment = _{ ";" ~ (!newline ~ any)* }