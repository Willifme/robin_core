//! # Abstract Syntax Tree
//!
//! This module defines the abstact syntax tree and how the nodes in the tree are evaluated
//! Tree nodes are generated by the parser
//! Each tree node has it's own struct associated with it

use itertools::{join, Itertools};

use error::Error;
use stdlib::Stdlib;
use to_javascript::ToJavaScript;

/// Define the number node
/// JavaScript uses 64-bit floating point numbers so f64 is used
#[derive(Clone, Debug, PartialEq)]
pub struct NumberExpression {
    pub value: f64,
}

impl NumberExpression {
    pub fn new(value: f64) -> NumberExpression {
        NumberExpression { value }
    }
}

impl ToJavaScript for NumberExpression {
    // Evaluation of numbers means just converting the number to a string
    fn eval(&mut self, _stdlib: &mut Stdlib) -> Result<String, Error> {
        Ok(format!("{}", self.value))
    }
}

/// Define the identifier node
/// We represent identifiers as strings. When evaluating the quotes around the stings are removed
#[derive(Clone, Debug, PartialEq)]
pub struct IdentifierExpression {
    pub value: String,
}

impl IdentifierExpression {
    pub fn new(value: String) -> IdentifierExpression {
        IdentifierExpression { value }
    }
}

impl ToJavaScript for IdentifierExpression {
    // For evaluating identifiers, we first check the variable table.
    // Then we check the function table.
    // If nothing is found in either table, then return an error
    fn eval(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        if let Some(_) = stdlib.variable_table.get(&self.value) {
            // TODO: Remove clone here
            Ok(self.value.clone())
        } else if let Some(_) = stdlib.function_table.get(&self.value) {
            Ok(self.value.clone())
        } else {
            // TODO: Remove clone here
            Err(Error::undefined_var(self.value.clone()))
        }
    }
}

/// Define the boolean node
#[derive(Clone, Debug, PartialEq)]
pub struct BooleanExpression {
    pub value: bool,
}

impl BooleanExpression {
    pub fn new(value: bool) -> BooleanExpression {
        BooleanExpression { value }
    }
}

impl ToJavaScript for BooleanExpression {
    // Evaluation of boolean means just converting the boolean to a string
    fn eval(&mut self, _stdlib: &mut Stdlib) -> Result<String, Error> {
        Ok(self.value.to_string())
    }
}

/// Define the string node
#[derive(Clone, Debug, PartialEq)]
pub struct StringExpression {
    pub value: String,
}

impl StringExpression {
    pub fn new(value: String) -> StringExpression {
        StringExpression { value }
    }
}

impl ToJavaScript for StringExpression {
    // Evaluating the string node is just retuning the value
    fn eval(&mut self, _stdlib: &mut Stdlib) -> Result<String, Error> {
        // TODO: Remove this clone
        Ok(self.value.clone())
    }
}

/// Define the list node
#[derive(Clone, Debug, PartialEq)]
pub struct ListExpression {
    pub value: Vec<Box<Expression>>,

    // A list can be optionally quoted
    qouted: bool,
}

impl ListExpression {
    pub fn new(qouted: bool, value: Vec<Box<Expression>>) -> ListExpression {
        ListExpression { qouted, value }
    }

    pub fn new_quoted(value: Vec<Box<Expression>>) -> ListExpression {
        ListExpression {
            qouted: true,
            value,
        }
    }

    pub fn new_unquoted(value: Vec<Box<Expression>>) -> ListExpression {
        ListExpression {
            qouted: false,
            value,
        }
    }

    // This function formats a Robin list to a JS array e.g. (1 2 3 4) => [1, 2, 3]
    // This function is called when an identifier isn't present as the first node
    fn format_list(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        // TODO: Remove clone
        // Evaluate each node and join them with a comma
        let args = join(
            self.value
                .clone()
                .into_iter()
                .map(|mut e| e.eval(stdlib))
                .fold_results(vec![], |mut i, expr| {
                    i.push(expr);

                    i
                })?,
            ",",
        );

        Ok(format!("[{}]", args))
    }

    // This function handles a function being called e.g. ((lambda (n) (+ n 1)) 5)
    fn eval_lambda_call(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        let mut function_args = self.value.clone();

        let (lambda, args) = function_args.split_first_mut().unwrap();

        match lambda {
            // The first argument should be a list
            box Expression::List(inner_list)
                // TODO: Remove clone
                // The first node within the list should be "lambda"
                if inner_list.value[0].clone().to_string() == "lambda" => {

                // Evaluate each expression and join them with a comma
                let args = join(
                    args.into_iter().map(|e| e.eval(stdlib)).fold_results(
                        vec![],
                        |mut i, expr| {
                            i.push(expr);

                            i
                        },
                    )?,
                    ",",
                );

                Ok(format!("({})({})", lambda.eval(stdlib)?, args))
            },

            // TODO: See if this is correct
            _ => self.eval_function(stdlib),
        }
    }

    // This funciton handles evaluating a function called.
    // e.g. (console.log "Hello, world!") => console.log("Hello, world!")
    fn eval_function(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        // Create a copy of the function args for later formatting
        let mut function_args = self.value.clone();

        // Get the name of the function then the arguments
        // TODO: Remove unwrap here
        let (name, args) = function_args.split_first_mut().unwrap();

        // Check if the function is in a table
        let expr_name = name.eval(stdlib)?;

        // Get the function from the table
        match (name, stdlib.function_table.clone().get(&expr_name)) {
            // Call the function
            // TODO: Remove clone
            (box Expression::Identifier(_), Some(func)) => func(expr_name.clone(), args, stdlib),

            // Otherwise, format the function
            (box Expression::Identifier(_), _) => {
                let args = join(
                    args.into_iter().map(|e| e.eval(stdlib)).fold_results(
                        vec![],
                        |mut i, expr| {
                            i.push(expr);

                            i
                        },
                    )?,
                    ",",
                );

                Ok(format!("({}({}))", expr_name, args))
            }

            // If nothing matches, convert to a JS array
            _ => self.format_list(stdlib),
        }
    }
}

impl ToJavaScript for ListExpression {
    fn eval(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        // The expression is quoted automatically if the ' is used
        // We send all the arguments when evaluating
        match (self.qouted, self.value.get(0)) {
            // Handle lists with quotes
            (true, _) => stdlib.function_table.get(&String::from("quote")).unwrap()(
                "quote".to_string(),
                self.value.as_mut_slice(),
                stdlib,
            ),

            // Handle lambda calls
            (false, Some(box Expression::List(_))) => self.eval_lambda_call(stdlib),

            // Handle function calls
            (false, Some(_)) => self.eval_function(stdlib),

            // Handle empty strings
            (false, _) => Ok(String::from("[]")),
        }
    }
}

// The Expression enum is the AST tree
// Each node in the AST has an associated struct
#[derive(Clone, Debug, PartialEq)]
pub enum Expression {
    Number(NumberExpression),
    Identifier(IdentifierExpression),
    Boolean(BooleanExpression),
    String(StringExpression),
    List(ListExpression),
}

// Consider using ToString
impl Expression {
    // Used to convert expressions to string
    pub fn to_string(self) -> String {
        match self {
            Expression::Number(expr) => expr.value.to_string(),
            Expression::Identifier(expr) => expr.value,
            Expression::Boolean(expr) => expr.value.to_string(),
            Expression::String(expr) => expr.value,
            Expression::List(ref list_expr) => {
                // Call to_string for each node member and join them with a comma
                let list_fmt = list_expr
                    .value
                    .clone()
                    .into_iter()
                    .map(|expr| expr.to_string())
                    .collect::<Vec<String>>()
                    .join(",");

                format!("[{}]", list_fmt)
            }
        }
    }
}

impl ToJavaScript for Expression {
    // Evaluate each node by delegating to the structs evaluate function
    fn eval(&mut self, stdlib: &mut Stdlib) -> Result<String, Error> {
        match self {
            // Delegate to the node's evaluate function
            Expression::Number(expr) => expr.eval(stdlib),
            Expression::Identifier(expr) => expr.eval(stdlib),
            Expression::Boolean(expr) => expr.eval(stdlib),
            Expression::String(expr) => expr.eval(stdlib),
            Expression::List(expr) => expr.eval(stdlib),
        }
    }
}
